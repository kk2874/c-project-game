#include <SDL.h>
#include <random>
#include <vector>

const int WINDOW_WIDTH = 800;
const int WINDOW_HEIGHT = 600;
const int BALL_RADIUS = 20;
const int BRICK_WIDTH = 100;
const int BRICK_HEIGHT = 50;
const int NUM_BRICKS_X = 8;
const int NUM_BRICKS_Y = 5;
const int PADDLE_WIDTH = 100;
const int PADDLE_HEIGHT = 20;
const int PADDLE_SPEED = 30;
const float BALL_SPEED = 0.05; 

struct Ball {
    float x, y;
    float vx, vy;
    int radius;
};

struct Brick {
    int x, y;
    int width, height;
    SDL_Color color;
    bool active;
};

struct Paddle {
    float x, y;
    int width, height;
    SDL_Color color;
};

int main(int argc, char* argv[]) {
    SDL_Init(SDL_INIT_VIDEO);

    SDL_Window* window = SDL_CreateWindow("Brick Breaker", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_SHOWN);
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);

    Ball ball = { WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2 - BALL_RADIUS * 2, BALL_SPEED, -BALL_SPEED, BALL_RADIUS };
    std::vector<Brick> bricks;
    Paddle paddle = { WINDOW_WIDTH / 2 - PADDLE_WIDTH / 2, WINDOW_HEIGHT - PADDLE_HEIGHT, PADDLE_WIDTH, PADDLE_HEIGHT, {255, 255, 255} };

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> colDist(0.0, 1.0);

    for (int y = 0; y < NUM_BRICKS_Y; y++) {
        for (int x = 0; x < NUM_BRICKS_X; x++) {
            Brick brick = {
                x * BRICK_WIDTH, y * BRICK_HEIGHT,
                BRICK_WIDTH, BRICK_HEIGHT,
                {(Uint8)(colDist(gen) * 255), (Uint8)(colDist(gen) * 255), (Uint8)(colDist(gen) * 255)},
                true
            };
            bricks.push_back(brick);
        }
    }

    bool running = true;
    while (running) {
        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) {
                running = false;
            }
            else if (event.type == SDL_KEYDOWN) {
                
                if (event.key.keysym.sym == SDLK_LEFT) {
                    paddle.x -= PADDLE_SPEED;
                    if (paddle.x < 0) {
                        paddle.x = 0;
                    }
                }
                else if (event.key.keysym.sym == SDLK_RIGHT) {
                    paddle.x += PADDLE_SPEED;
                    if (paddle.x + paddle.width > WINDOW_WIDTH) {
                        paddle.x = WINDOW_WIDTH - paddle.width;
                    }
                }
            }
        }

        ball.x += ball.vx;
        ball.y += ball.vy;

        // 볼과 벽의 충돌 처리
        if (ball.x - ball.radius < 0 || ball.x + ball.radius > WINDOW_WIDTH) {
            ball.vx *= -1;
        }
        if (ball.y - ball.radius < 0) {
            ball.vy *= -1;
        }
        // 볼과 패들의 충돌 처리
        if (ball.y + ball.radius >= paddle.y && ball.y + ball.radius <= paddle.y + paddle.height &&
            ball.x >= paddle.x && ball.x <= paddle.x + paddle.width) {
            ball.vy *= -1;
        }
        if (ball.y + ball.radius > WINDOW_HEIGHT) {
            running = false;
        }

        // 볼과 벽돌의 충돌 처리
        for (auto& brick : bricks) {
            if (brick.active && ball.x + ball.radius > brick.x && ball.x - ball.radius < brick.x + brick.width &&
                ball.y + ball.radius > brick.y && ball.y - ball.radius < brick.y + brick.height) {
                brick.active = false;
                if (ball.x < brick.x || ball.x > brick.x + brick.width) {
                    ball.vx *= -1;
                }
                else {
                    ball.vy *= -1;
                }
            }
        }

        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderClear(renderer);

        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_Rect ballRect = { (int)(ball.x - ball.radius), (int)(ball.y - ball.radius), ball.radius * 2, ball.radius * 2 };
        SDL_RenderFillRect(renderer, &ballRect);

        SDL_SetRenderDrawColor(renderer, paddle.color.r, paddle.color.g, paddle.color.b, 255);
        SDL_Rect paddleRect = { (int)paddle.x, (int)paddle.y, paddle.width, paddle.height };
        SDL_RenderFillRect(renderer, &paddleRect);

        for (const auto& brick : bricks) {
            if (brick.active) {
                SDL_SetRenderDrawColor(renderer, brick.color.r, brick.color.g, brick.color.b, 255);
                SDL_Rect brickRect = { brick.x, brick.y, brick.width, brick.height };
                SDL_RenderFillRect(renderer, &brickRect);
            }
        }

        SDL_RenderPresent(renderer);
    }

    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}
